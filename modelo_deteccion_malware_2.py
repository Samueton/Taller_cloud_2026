# -*- coding: utf-8 -*-
"""Modelo_Deteccion_Malware.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16RoBXKj4N2QawXKoUbGYDhOjy5yBxHvf
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import pickle
from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import (confusion_matrix, classification_report, accuracy_score,
                             f1_score, precision_score, roc_auc_score, roc_curve)
from sklearn.impute import SimpleImputer

# --- 1. PREPARACIÓN Y LIMPIEZA ---
df = pd.read_csv('dataset_malware.csv')
X = df.select_dtypes(include=[np.number])
y = df['Class']

# Codificación de etiquetas
le = LabelEncoder()
y_encoded = le.fit_transform(y)

# Limpieza de nulos e infinitos
X.replace([np.inf, -np.inf], np.nan, inplace=True)
imputer = SimpleImputer(strategy='mean')
X_imputed = imputer.fit_transform(X)

# Escalado y PCA (Reducción de dimensionalidad)
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X_imputed)

pca = PCA(n_components=0.95)
X_pca = pca.fit_transform(X_scaled)

# División estratificada
X_train, X_test, y_train, y_test = train_test_split(
    X_pca, y_encoded, test_size=0.25, random_state=42, stratify=y_encoded
)

# --- 2. ANÁLISIS DEL MODELO (RANDOM FOREST) ---
# Se mantiene el hiperparámetro class_weight='balanced' por ser útil en detección de malware
modelo_rf = RandomForestClassifier(n_estimators=100, class_weight='balanced', random_state=42)

# Entrenamiento
modelo_rf.fit(X_train, y_train)
preds = modelo_rf.predict(X_test)
probs = modelo_rf.predict_proba(X_test)

# Métricas principales
acc = accuracy_score(y_test, preds)
f1 = f1_score(y_test, preds, average='weighted')
prec = precision_score(y_test, preds, average='weighted')

# Cálculo de AUC y Curva ROC
if len(np.unique(y_encoded)) == 2:
    auc = roc_auc_score(y_test, probs[:, 1])
    fpr, tpr, _ = roc_curve(y_test, probs[:, 1])
else:
    auc = roc_auc_score(y_test, probs, multi_class='ovr')
    # Para multiclase, graficamos la primera clase vs resto
    fpr, tpr, _ = roc_curve(pd.get_dummies(y_test).iloc[:, 0], probs[:, 0])

# --- 3. VISUALIZACIÓN ---
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(14, 5))

# A. Matriz de Confusión
cm = confusion_matrix(y_test, preds)
sns.heatmap(cm, annot=True, fmt='d', cmap='viridis', ax=ax1)
ax1.set_title('Matriz de Confusión: Random Forest')
ax1.set_xlabel('Predicción')
ax1.set_ylabel('Real')

# B. Curva ROC
ax2.plot(fpr, tpr, color='darkorange', label=f'Random Forest (AUC: {auc:.3f})')
ax2.plot([0, 1], [0, 1], color='navy', linestyle='--')
ax2.set_title('Curva ROC')
ax2.set_xlabel('Falsos Positivos')
ax2.set_ylabel('Verdaderos Positivos')
ax2.legend()

plt.tight_layout()
plt.show()

# --- 4. REPORTES Y PERSISTENCIA ---
print("\n>>> DETALLE DE CLASIFICACIÓN: Random Forest")
print(classification_report(y_test, preds, target_names=le.classes_.astype(str)))

# Tabla resumen
resultados = {
    "Tecnica": "Random Forest",
    "Accuracy": round(acc, 4),
    "F1-Score": round(f1, 4),
    "Precision": round(prec, 4),
    "ROC-AUC": round(auc, 4)
}
print("\n" + "="*40)
print("   RESUMEN DE RENDIMIENTO")
print("="*40)
for k, v in resultados.items():
    print(f"{k}: {v}")
print("-" * 40)

# Guardar objetos
objetos_a_guardar = {
    'modelo_final': modelo_rf,
    'scaler': scaler,
    'pca': pca,
    'imputer': imputer,
    'label_encoder': le
}

with open('pipeline_malware.pkl', 'wb') as f:
    pickle.dump(objetos_a_guardar, f)

# Si también deseas guardar el scaler
with open('scaler.pkl', 'wb') as archivo_salida:
    pickle.dump(scaler, archivo_salida)